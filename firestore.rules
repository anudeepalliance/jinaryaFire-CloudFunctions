rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  
     //Rules for the User Document
    match /Users/{uid} {
    	//Users can read data about all other users
    	allow read : if request.auth != null;
      //Users can edit data if it is their own data
      allow write: if request.auth.uid == uid;

    //Rules for the User Profile Document
    match /ProfileInfo/{againUid} {
    	//Users can read data about all other users
    	allow read : if request.auth != null
      //Users can edit data if it is their own data
      allow write: if request.auth.uid == uid;
    }
      
      match /following/{followingPersonUid} {
        //everybody is allowed to see everyone else's following
        allow read: if true;
      //Only the user is authorised to create 
      //& delete to his following sub-collection
      allow create, delete: if request.auth.uid == uid;
      //allow update if user is trying to update just the number of compliments sent field
      allow update: if isUpdatingOnlyNoOfCompsSentOrComplimentSentAtField();
      }

    //custom function to check if client is trying to update anything other 
    //than likes or views field of the complimentSent doc
    function isUpdatingOnlyNoOfCompsSentOrComplimentSentAtField() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfComplimentsSent']) || 
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['complimentSentAt'])
    }

    //custom function to check if client is trying to update anything other 
    //than followingBack field at FollowerPerson Doc
    function isUpdatingOnlyFollowingBackField() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followingBack']);
    }

      
      match /followers/{followerPersonUid} {
      //everybody is allowed to see everyone else's followers
      allow read: if true;
      //Only the user is authorised to create
      //& delete and add to his followers sub-collection
      allow create, delete: if request.auth.uid == uid;
      allow update: if request.auth.uid == uid && isUpdatingOnlyFollowingBackField();
      }
      
      match /complimentsSentNumbers/{followingPersonUid} {
      //Only the owner can create and read
      //can update if updating the noOfComplimentsSent
      allow read,create : if request.auth.uid == uid;
      allow update : if request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfComplimentsSent']);
      }
      
      match /blocked/{blockedPersonUid} {
      //Only the user is authorised to read, delete 
      //and add to his blocked sub-collection
      allow read,create, delete: if request.auth.uid == uid;
      }
      
      match /blockedBy/{blockedByPersonUid} {
      //User is authorised to just read 
      //his blocked sub-collection
      allow read: if request.auth.uid == uid;
      }
      
      match /notificationToken/{tokenId} {
      //Only the user is authorised to read and write
      //to his followers sub-collection
      allow read, create, update: if request.auth.uid == uid;
      allow delete : if false;
      }
      
      match /Notifications/{randomId} {
      //User is authorised to create and read
      //to his Notifications sub-collection but not create
      allow read: if request.auth.uid == uid;
      allow update: if request.auth.uid == uid && isUpdatingOnlyWasClickedField();
      allow create: if request.auth.uid == uid && isCreatingOnlyNoOfNotificationsReceivedDoc();
      }


    function isCreatingOnlyNoOfNotificationsReceivedDoc() {
      return request.resource.data.keys().hasOnly(['noOfNotificationsReceived'])
    }


    function isUpdatingOnlyWasClickedField() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['wasClicked'])
    }

    //custom function to check if client is trying to update anything other 
    //than likes or views field of the complimentSent doc
    function isUpdatingOnlyLikesOrViewsCounter() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfLikes']) || 
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfViews'])
    }

    //function to track if the complimentReceiver to trying to update the wasRead, senderBlocked or 
    //followingStatus Booleans in the ComplimentReceived Doc
    function isComplimentReceiverUpdatingWasReadOrComplimentBlockedOrFollowingStatusOrReceivedLikedField() {
      return request.resource.data.receiverUid == uid && 
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['complimentRead']) ||
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderBlocked']) ||
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['receiverLiked']) ||
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followingStatus']);
    }

    function isComplimentSenderUpdatingReceiverBlockedStatusOrSenderNameOrSenderUserNameOrSenderLikedField() {
      return resource.data.senderUid == request.auth.uid && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['receiverBlocked']) ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderName']) ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderLiked']) ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderUserName']);
    }

    //The rules for complimentsReceivedLike Docs
    match /complimentsReceived/{randomComplimentId} {
      //allow read for compliment receivers, the followers and compliment senders
      //sender is already a follower but separate rule is added just in case the sender unfollows a person later
      allow read: if request.auth.uid == uid
      || exists(/databases/$(database)/documents/Users/$(uid)/followers/$(request.auth.uid)) 
      || getComplimentReceivedDocData().data.senderUid == request.auth.uid;

      //allow create for the followers
      allow create: if exists(/databases/$(database)/documents/Users/$(uid)/followers/$(request.auth.uid))

      //allow update only if trying to update the likes or viewCounter fields
      allow update: if isUpdatingOnlyLikesOrViewsCounter() ||
        isComplimentReceiverUpdatingWasReadOrComplimentBlockedOrFollowingStatusOrReceivedLikedField() ||
        isComplimentSenderUpdatingReceiverBlockedStatusOrSenderNameOrSenderUserNameOrSenderLikedField();

      //allow delete compliment to only the receiver
      allow delete: if request.auth.uid == uid;
    }


    //get complimentReceivedDocData
    function getComplimentReceivedDocData() {
      return get(/databases/$(database)/documents/Users/$(request.data.receiverUid)/complimentsReceived/{randomComplimentId}).data
    }

        //The rules for complimentsReceivedLikes sub coll
        match /complimentsReceived/{randomComplimentId}/complimentLikes/{likerUid} {
        //allow read, create for compliment receivers, the followers and compliment senders
        //sender is already a follower but separate rule is added just in case the sender unfollows a person later
        allow read, create: if request.auth.uid != null
         || exists(/databases/$(database)/documents/Users/$(uid)/followers/$(request.auth.uid)) 
          || getComplimentReceivedDocData().data.senderUid == request.auth.uid;

        //allow delete to only the likers so users can unlike their own likes and cannot unlike for other users
        allow delete: if request.auth.uid == likerUid;
        }

    
    //End of Users/{uid} parent
    }


      //The rules for complimentsReceivedSubCollection
      //Using a collectionGroup query for retreving compliments sent
      //so some path wild card is added since according to firestore rules,
      //The collectioncomplimentsReceived can exist anywhere in the DB
			match /{somepath=**}/complimentsReceived/{randomComplimentId} {
        //Allow read permission to compliment receivers, followers of the receiver
        //and the sender of the compliment 
        //sender is already a follower but separate rule is added just in case the sender unfollows a person later
        allow read: if request.auth.uid == resource.data.receiverUid || 
          exists(/databases/$(database)/documents/Users/$(resource.data.receiverUid)/followers/$(request.auth.uid)) || 
          request.auth.uid == resource.data.senderUid;

      }

    //Experiment Collection users-t
    match /users-t/{userdIds} {
    	//Users can read data about all other users
    	allow read : if request.auth.uid in resource.data.followers || resource.data.following
    }

match/ComplimentIdeas/{ideaId} {
  //everyone can read compliment ideas, only admins will create & write to this via console
  allow read: if true;
}


  //End of rules  
  }
  
}