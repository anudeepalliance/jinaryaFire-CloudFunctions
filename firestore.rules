rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
  
     //Rules for the User Document
    match /Users/{uid} {
    	//Users can read data about all other users
    	allow read: if request.auth != null;
      //Users can edit data if it is their own data
      allow write: if request.auth.uid == uid;

    //Rules for the User Profile Document
    match /ProfileInfo/{againUid} {
    	//Users can read data about all other users
    	allow read: if request.auth != null
      //Users can edit data if it is their own data
      allow write: if request.auth.uid == uid;
    }

    match /whatsNew/{whatsNewDocId} {
      allow create: if isCreatingOnlyTotalNoItemsOrNoOfUnReadWhatsItemsDoc();
      allow update: if isUpdatingOnlyIsReadFieldOrNoOfUnReadItemsField();
      //users are allows to read their WhatsNew Documents
      allow read: if true;
    }
      
      match /following/{followingPersonUid} {
        //everybody is allowed to see everyone else's following
        allow read: if true;
      //Only the user is authorised to create
      //& delete to his following sub-collection
      allow create, delete: if request.auth.uid == uid;
      //allow update if user is trying to update just the number of compliments sent field
      allow update: if isUpdatingOnlyNoOfCompsSentOrComplimentSentAtOrInterestMeter();
      }

    
    //In whatsNewSubColl check if user is creating only 
    //totalNoOfWhatsNewItems or totalNoOfUnReadWhatsNewItems Doc
    function isCreatingOnlyTotalNoItemsOrNoOfUnReadWhatsItemsDoc() {
      return request.resource.data.keys().hasOnly(['totalNoOfItems']) || 
      request.resource.data.keys().hasOnly(['noOfUnReadItems'])
    }

    //Allow update only if user is updating the isRead field or the noOfUnRead Items field 
    //of the WhatsNewDoc
    function isUpdatingOnlyIsReadFieldOrNoOfUnReadItemsField() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']) ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfUnReadItems'])
    }
    
    
    function isUpdatingOnlyNoOfCompsSentOrComplimentSentAtOrInterestMeter() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfComplimentsSent']) || 
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['complimentSentAt']) || 
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['interestMeter'])
    }

    //custom function to check if client is trying to update anything other 
    //than followingBack field at FollowerPerson Doc
    function isUpdatingOnlyFollowingBackField() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followingBack']);
    }

      
      match /followers/{followerPersonUid} {
        //everybody is allowed to see everyone else's followers
        allow read: if true;
        //Only the user is authorised to create
        //& delete and add to his followers sub-collection
        allow create, delete: if request.auth.uid == uid;
        allow update: if request.auth.uid == uid && isUpdatingOnlyFollowingBackField();
      }
      
      match /complimentsSentNumbers/{followingPersonUid} {
        //Only the owner can create and read
        //can update if updating the noOfComplimentsSent
        allow read, create: if request.auth.uid == uid;
        allow update: if request.auth.uid == uid && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfComplimentsSent']);
      }
      
      match /blocked/{blockedPersonUid} {
        //Only the user is authorised to read, delete 
        //and add to his blocked sub-collection
        allow read,create, delete: if request.auth.uid == uid;
      }
      
      match /blockedBy/{blockedByPersonUid} {
        //User is authorised to just read 
        //his blocked sub-collection
        allow read: if request.auth.uid == uid;
      }
      
      match /notificationToken/{tokenId} {
        //Only the user is authorised to read and write
        //to his followers sub-collection
        allow read, create, update: if request.auth.uid == uid;
        allow delete : if false;
      }
      
      match /Notifications/{randomId} {
        //User is authorised to create and read
        //to his Notifications sub-collection but not create
        allow read: if request.auth.uid == uid;
        allow update: if request.auth.uid == uid && isUpdatingOnlyWasClickedField();
        allow create: if request.auth.uid == uid && isCreatingOnlyNoOfNotificationsReceivedDoc();
        allow delete: if request.auth.uid == uid;
      }

     match /pokersForInsights/{randomId} {
        //User is authorised to read
        //to his pokersForInsights sub-collection but not create
        //create and delete will be done by CF only
        allow read: if request.auth.uid == uid;
     }


    function isCreatingOnlyNoOfNotificationsReceivedDoc() {
      return request.resource.data.keys().hasOnly(['noOfNotificationsReceived'])
    }


    function isUpdatingOnlyWasClickedField() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['wasClicked'])
    }

    //custom function to check if client is trying to update anything other 
    //than likes or views field of the complimentSent doc
    function isUpdatingOnlyLikesOrViewsCounter() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['noOfLikes', 'noOfViews']);
    }

    //function to track if the complimentReceiver to trying to update the wasRead, senderBlocked or 
    //followingStatus Booleans in the ComplimentReceived Doc
    function isComplimentReceiverUpdatingWasReadOrComplimentBlockedOrFollowingStatusOrReceivedLikedField() {
      return resource.data.receiverUid == uid && 
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['complimentRead']) ||
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderBlocked']) ||
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['receiverLiked']) ||
      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followingStatus']);
    }

    function isComplimentSenderUpdatingReceiverBlockedStatusOrSenderNameOrSenderUserNameOrSenderLikedField() {
      return resource.data.senderUid == request.auth.uid && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['receiverBlocked', 'senderName', 'senderLiked','senderUserName']);
        // request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderName']) ||
        // request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderLiked']) ||
        // request.resource.data.diff(resource.data).affectedKeys().hasOnly(['senderUserName']);
    }

    //Check if the requested client is a follower
    function isFollower() {
      return exists(/databases/$(database)/documents/Users/$(uid)/followers/$(request.auth.uid)) 
    }

    //Check if the insight owner is updating ownerLiked field
    function isInsightOwnerUpdatingOwnerLikedOrNoOfLikesField() {
      return request.auth.uid == uid && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['ownerLiked', 'noOfLikes'])
    }

    //The rules for complimentsReceivedLike Docs
    match /complimentsReceived/{randomComplimentId} {
      //allow read for compliment receivers, the followers and compliment senders
      //sender is already a follower but separate rule is added just in case the sender unfollows a person later
      allow read: if request.auth.uid == uid
      || isFollower()
      || getComplimentReceivedDocData().data.senderUid == request.auth.uid;

      //allow create for the followers
      // allow create: if exists(/databases/$(database)/documents/Users/$(uid)/followers/$(request.auth.uid))
      //compliments are sent and received via CF only so no one is allowed to create compliments
      allow create: if false

      //allow update only if trying to update the likes or viewCounter fields
      allow update: if isUpdatingOnlyLikesOrViewsCounter() ||
        isComplimentReceiverUpdatingWasReadOrComplimentBlockedOrFollowingStatusOrReceivedLikedField() ||
        isComplimentSenderUpdatingReceiverBlockedStatusOrSenderNameOrSenderUserNameOrSenderLikedField();

      //allow delete compliment to only the receiver
      allow delete: if request.auth.uid == uid;
    }


    //get complimentReceivedDocData
    function getComplimentReceivedDocData() {
      return get(/databases/$(database)/documents/Users/$(request.data.receiverUid)/complimentsReceived/{randomComplimentId}).data
    }

        //The rules for complimentsReceivedLikes sub coll
        match /complimentsReceived/{randomComplimentId}/complimentLikes/{likerUid} {
        //allow read, create for compliment receivers, the followers and compliment senders
        //sender is already a follower but separate rule is added just in case the sender unfollows a person later
        allow read, create: if request.auth.uid == uid
         || isFollower()
          || getComplimentReceivedDocData().data.senderUid == request.auth.uid;

        //allow delete to only the likers so users can unlike their own likes and cannot unlike for other users
        allow delete: if request.auth.uid == likerUid;
        }

    //The rules for insights sub coll
    match /insights/{randomInsightId} {
      //allow read for insight owners and the followers
      allow read: if request.auth.uid == uid
      || isFollower()

      //allow create for owners only
      allow create: if request.auth.uid == uid

      //allow update only if user or watcher is trying to update the likes or viewCounter fields
      allow update: if isUpdatingOnlyLikesOrViewsCounter() || isInsightOwnerUpdatingOwnerLikedOrNoOfLikesField();

      //allow delete insight by owner of the insight
      allow delete: if request.auth.uid == uid;
    }

        //The rules for insight likes sub coll
        match /insights/{randomInsightId}/insightLikes/{likerUid} {
        //allow read, create for owners and the followers
        allow read, create: if request.auth.uid == uid
         || isFollower()

        //allow delete to only the likers so users can unlike their own likes and cannot unlike for other users
        allow delete: if request.auth.uid == likerUid;
        }

    
    //End of Users/{uid} parent
    }


      //The rules for complimentsReceivedSubCollection
      //Using a collectionGroup query for retreving compliments sent
      //so some path wild card is added since according to firestore rules,
      //The collectioncomplimentsReceived can exist anywhere in the DB
			match /{somepath=**}/complimentsReceived/{randomComplimentId} {
        //Allow read permission to compliment receivers, followers of the receiver
        //and the sender of the compliment 
        //sender is already a follower but separate rule is added just in case the sender unfollows a person later
        allow read: if request.auth.uid == resource.data.receiverUid || 
        request.auth.uid == resource.data.senderUid ||
          exists(/databases/$(database)/documents/Users/$(resource.data.receiverUid)/followers/$(request.auth.uid));
      }

      //Experiment Collection users-t
      match /users-t/{userdIds} {
        //Users can read data about all other users
        allow read : if request.auth.uid in resource.data.followers || resource.data.following
      }

      match/ComplimentIdeas/{ideaId} {
        //everyone can read compliment ideas, only admins will create & write to this via console
        allow read: if true;
      }

      match/InsightIdeas/{ideaId} {
        //everyone can read insight ideas, only admins will create & write to this via console
        allow read: if true;
      }


  //End of rules  
  }
  
}